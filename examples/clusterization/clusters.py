'''
Люди одного возраста, имеющие примерно одинаковый уровень доходов, могут одеваться совершенно по-разному, но с помощью кластеризации удается выявить «островки моды» и использовать эти данные для выработки стратегии маркетинга или розничных продаж. Кластеризация также активно применяется в вычислительной биологии для обнаружения групп генов, демонстрирующих сходное поведение. Это может служить указанием на то, что они будут одинаково реагировать на лечение или что образовались на одном пути биологического развития.

Кластеризация – пример обучения без учителя. В отличие от нейронных сетей или деревьев решений, алгоритмам обучения без учителя не сообщаются правильные ответы. Их задача – обнаружить структуру в наборе данных, когда ни один элемент данных не является ответом. В примере с модной одеждой кластер ничего не говорит продавцу о том,
что может купить конкретный индивидуум, и не дает прогнозов о том, в какой островок моды попадет новый клиент. Назначение алгоритмов кластеризации состоит в том, чтобы обнаружить отдельные группы в предъявленном наборе данных.
'''

from math import sqrt
def readfile(filename):
    lines=[line for line in open(filename)]
    # Первая строка содержит названия столбцов
    colnames = lines[0].strip( ).split('\t')[1:]
    rownames = []
    data = []
    for line in lines[1:]:
        p = line.strip( ).split('\t')
        # Первый столбец в каждой строке содержит название строки
        rownames.append(p[0])
        # Остальные ячейки содержат данные этой строки
        data.append([float(x) for x in p[1:]])
    return rownames,colnames,data

rownames,colnames,data = readfile('blogdata.txt')
print('rownames,colnames,data', rownames,colnames,data)


def pearson(v1,v2):
    # Простые суммы
    sum1=sum(v1)
    sum2=sum(v2)
    # Суммы квадратов
    sum1Sq=sum([pow(v,2) for v in v1])
    sum2Sq=sum([pow(v,2) for v in v2])
    # Суммы произведений
    pSum=sum([v1[i]*v2[i] for i in range(len(v1))])
    # Вычисляем r (коэффициент Пирсона)
    num=pSum-(sum1*sum2/len(v1))
    den=sqrt((sum1Sq-pow(sum1,2)/len(v1))*(sum2Sq-pow(sum2,2)/len(v1)))
    if den==0: return 0
    return 1.0-num/den