'''
Стохастическая оптимизация
Обычно методы оптимизации используются для задач, имеющих множество возможных решений, которые зависят от многих переменных, а результат существенно зависит от сочетания этих переменных. У методов оптимизации весьма широкая область применения: в физике они используются для изучения молекулярной динамики, в биологии – для прогнозирования белковых структур, а в информатике – для определения времени работы алгоритма в худшем случае. В НАСА методы оптимизации применяют даже для проектирования антенн с наилучшими эксплуатационными характеристиками.
По существу, оптимизация сводится к поиску наилучшего решения задачи путем апробирования различных решений и сравнения их между собой для оценки качества. Обычно оптимизация применяется в тех случаях, когда число решений слишком велико и перебрать их все невозможно
'''

'''
Планирование путешествия группы людей, которые, отправляясь из разных мест, должны прибыть в одно и то же место, всегда вызывало сложности и представляет собой интересную оптимизационную задачу.
'''

import time
import random
import math

people = [
    ('Seymour','BOS'),
    ('Franny','DAL'),
    ('Zooey','CAK'),
    ('Walt','MIA'),
    ('Buddy','ORD'),
    ('Les','OMA')
]
# Место назначения – аэропорт Ла Гардиа в Нью-Йорке
destination='LGA'



# s = [1, 4, 3, 2, 7, 3, 6, 3, 2, 4, 5, 3]
domain = [(0, 8)] * (len(people) * 2)

'''
Члены семьи живут в разных концах страны и хотят встретиться в Нью-Йорке. Все они должны вылететь в один день и в один день улететь и при этом в целях экономии хотели бы уехать из аэропорта и приехать в него на одной арендованной машине. Ежедневно в Нью-Йорк из мест проживания любого члена семьи отправляются десятки рейсов, все в разное время. Цена билета и время в пути для каждого рейса разные.

Загрузим эти данные в словарь, для которого ключом будет аэропорт отправления и аэропорт назначения, а значением – список, содержащий детальную информацию о рейсах.
'''

flights = {}
# 
for line in open('schedule.txt'):
    origin, dest, depart, arrive, price = line.strip().split(',')
    flights.setdefault((origin, dest), [])

    # Add details to the list of possible flights
    flights[(origin, dest)].append((depart, arrive, int(price)))

'''
Сейчас будет полезно написать служебную функцию getminutes , которая вычисляет смещение данного момента времени от начала суток в минутах. Так нам будет удобнее вычислять время в пути и время ожидания.
'''
def getminutes(t):
    x = time.strptime(t, '%H:%M')
    return x[3] * 60 + x[4]

'''
Для подобных задач необходимо определиться со способом представления потенциальных решений. Каждое число обозначает рейс, которым решил лететь участник группы, причем 0 – это первый рейс в течение суток, 1 – второй и т. д. Так как каждый человек должен лететь туда и обратно, то длина списка в два раза больше количества людей. 
Поскольку интерпретировать решение, имея перед собой лишь список чисел, трудно, нам понадобится функция, которая печатает выбранные рейсы в виде красиво отформатированной таблицы.
'''
def printschedule(r):
    rng = range(int(len(r) / 2))
    for d in rng:
        name = people[d][0]
        origin = people[d][1]
        out = flights[(origin, destination)][int(r[d])]
        ret = flights[(destination, origin)][int(r[d + 1])]
        print(
            '%10s%10s %5s-%5s $%3s %5s-%5s $%3s' % 
            (
                name, origin,
                out[0], out[1], out[2],
                ret[0], ret[1], ret[2]
            )
        )


# printschedule(s)


'''
Целевая функция
Ключом к решению любой задачи оптимизации является целевая функция, и именно ее обычно труднее всего отыскать. Цель оптимизационного алгоритма состоит в том, чтобы найти такой набор входных переменных – в данном случае рейсов, – который минимизирует целевую функцию. Поэтому целевая функция должна возвращать значение, показывающее, насколько данное решение неудовлетворительно. Не существует никакого определенного масштаба неудовлетворительности; требуется лишь, чтобы возвращаемое значение было тем больше, чем хуже решение.

Часто, когда переменных много, бывает трудно сформулировать критерий, хорошее получилось решение или плохое. Рассмотрим несколько параметров, которые можно измерить в примере с групповым путешествием:
    Цена - Полная стоимость всех билетов или, возможно, среднее значение, взвешенное с учетом финансовых возможностей.
    Время в пути - Суммарное время, проведенное всеми членами семьи в полете.
    Время ожидания - Время, проведенное в аэропорту в ожидании прибытия остальных членов группы.
    Время вылета - Если самолет вылетает рано утром, это может увеличивать общую стоимость из-за того, что путешественники не выспятся.
    Время аренды автомобилей - Если группа арендует машину, то вернуть ее следует до того часа, когда она была арендована, иначе придется платить за лишний день.

Определившись с тем, какие переменные влияют на стоимость, нужно решить, как из них составить одно число. В нашем случае можно, например, выразить в деньгах время в пути или время ожидания в аэропорту. Скажем, каждая минута в воздухе эквивалентна $1 (иначе говоря, можно потратить лишние $90 на прямой рейс, экономящий полтора часа), а каждая минута ожидания в аэропорту эквивалентна $0,50. Можно было бы также приплюсовать стоимость лишнего дня аренды машины, если для всех имеет смысл вернуться в аэропорт к более позднему часу. Кроме того, добавляется штраф $50, если машина возвращена в более поздний час, чем арендована.
'''

def schedulecost(sol):
    totalprice = 0
    latestarrival = 0
    earliestdep = 24 * 60

    for d in range(int(len(sol) / 2)):
        # Get the inbound and outbound flights
        origin = people[d][1]
        outbound = flights[(origin, destination)][int(sol[d])]
        returnf = flights[(destination, origin)][int(sol[d + 1])]

        # Total price is the price of all outbound and return flights
        totalprice += outbound[2]
        totalprice += returnf[2]

        # Track the latest arrival and earliest departure
        if latestarrival < getminutes(outbound[1]): 
            latestarrival = getminutes(outbound[1])
        if earliestdep > getminutes(returnf[0]): 
            earliestdep = getminutes(returnf[0])

    # Every person must wait at the airport until the latest person arrives.
    # They also must arrive at the same time and wait for their flights.
    totalwait = 0  
    for d in range(int(len(sol) / 2)):
        origin = people[d][1]
        outbound = flights[(origin, destination)][int(sol[d])]
        returnf = flights[(destination, origin)][int(sol[d + 1])]
        totalwait += latestarrival - getminutes(outbound[1])
        totalwait += getminutes(returnf[0]) - earliestdep  

    # Does this solution require an extra day of car rental? That'll be $50!
    if latestarrival > earliestdep: 
        totalprice += 50

    return totalprice + totalwait


# cost = schedulecost(s)
# print('cost', cost)

'''
Случайный поиск – не самый лучший метод оптимизации, но он позволит нам ясно понять, чего пытаются достичь все алгоритмы, а также послужит эталоном, с которым можно будет сравнивать другие алгоритмы. 
Domain – это список пар, определяющих минимальное и максимальное значения каждой переменной.
costf – это целевая функция;
'''

def randomoptimize(domain,costf):
    best = 999999999
    bestr = None
    for i in range(0, 1000):
        # Create a random solution
        r = [
            float(random.randint(domain[i][0], domain[i][1])) 
            for i in range(len(domain))
        ]

        # Get the cost
        cost = costf(r)

        # Compare it to the best one so far
        if cost < best:
            best = cost
            bestr = r

    return r


'''

s = randomoptimize(domain, schedulecost)
schedulecost(s)
printschedule(s)

   Seymour       BOS  8:04-10:11 $ 95  9:58-11:18 $130
    Franny       DAL  9:08-12:12 $364 10:51-14:16 $256
     Zooey       CAK 10:53-13:36 $189 16:33-18:15 $253
      Walt       MIA 17:07-20:04 $291  9:25-12:46 $295
     Buddy       ORD  9:42-11:32 $169  7:50-10:08 $164
       Les       OMA  7:39-10:24 $219  8:04-10:59 $136

'''



'''
Алгоритм спуска с горы
Альтернативный метод случайного поиска называется алгоритмом спуска с горы (hill climbing). Он начинает со случайного решения и ищет лучшие решения (с меньшим значением целевой функции) по соседству. Можно провести аналогию со спуском с горы, отсюда и название.

В данном случае это означает просмотр таких расписаний, для которых один человек выбирает рейс, вылетающий чуть раньше или чуть позже. Для каждого из соседних расписаний вычисляется стоимость, и расписание с наименьшей стоимостью становится новым решением. Этот процесс повторяется и завершается, когда ни одно из соседних расписаний не дает улучшения стоимости.

Для выбора начального решения эта функция генерирует случайный список чисел из заданного диапазона. Соседи текущего решения ищутся путем посещения каждого элемента списка и создания двух новых списков, в одном из которых этот элемент увеличен на единицу, а в другом уменьшен на единицу. Лучшее из соседних решений становится новым решением. Спускаясь по склону, мы необязательно отыщем наилучшее возможное решение. Найденное решение будет локальным минимумом, то есть лучшим из всех в ближайшей окрестности, но это не означает, что оно вообще лучшее. Решение, лучшее среди всех возможных, называется глобальным минимумом, и именно его хотят найти все алгоритмы оптимизации. Один из возможных подходов к решению проблемы называется спуском с горы со случайным перезапуском.
'''

def hillclimb(domain, costf):
    # Create a random solution
    sol = [
        random.randint(domain[i][0], domain[i][1])
        for i in range(len(domain))
    ]
    # Main loop
    while 1:
        # Create list of neighboring solutions
        neighbors = []

        for j in range(len(domain)):
            # One away in each direction
            if sol[j] > domain[j][0]:
                neighbors.append(sol[0: j] + [sol[j] + 1] + sol[j + 1:])
            if sol[j] < domain[j][1]:
                neighbors.append(sol[0: j] + [sol[j] - 1] + sol[j + 1:])

        # See what the best solution amongst the neighbors is
        current = costf(sol)
        best = current
        for j in range(len(neighbors)):
            cost = costf(neighbors[j])
            if cost < best:
                best = cost
                sol = neighbors[j]

        # If there's no improvement, then we've reached the top
        if best == current:
            break

    return sol


'''
s = hillclimb(domain, schedulecost)
schedulecost(s)
printschedule(s)
'''


