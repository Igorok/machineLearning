'''
Стохастическая оптимизация
Обычно методы оптимизации используются для задач, имеющих множество возможных решений, которые зависят от многих переменных, а результат существенно зависит от сочетания этих переменных. У методов оптимизации весьма широкая область применения: в физике они используются для изучения молекулярной динамики, в биологии – для прогнозирования белковых структур, а в информатике – для определения времени работы алгоритма в худшем случае. В НАСА методы оптимизации применяют даже для проектирования антенн с наилучшими эксплуатационными характеристиками.
По существу, оптимизация сводится к поиску наилучшего решения задачи путем апробирования различных решений и сравнения их между собой для оценки качества. Обычно оптимизация применяется в тех случаях, когда число решений слишком велико и перебрать их все невозможно
'''

'''
Планирование путешествия группы людей, которые, отправляясь из разных мест, должны прибыть в одно и то же место, всегда вызывало сложности и представляет собой интересную оптимизационную задачу.
'''

import time
import random
import math

s = [1, 4, 3, 2, 7, 3, 6, 3, 2, 4, 5, 3]
people = [
    ('Seymour','BOS'),
    ('Franny','DAL'),
    ('Zooey','CAK'),
    ('Walt','MIA'),
    ('Buddy','ORD'),
    ('Les','OMA')
]
# Место назначения – аэропорт Ла Гардиа в Нью-Йорке
destination='LGA'


'''
Члены семьи живут в разных концах страны и хотят встретиться в Нью-Йорке. Все они должны вылететь в один день и в один день улететь и при этом в целях экономии хотели бы уехать из аэропорта и приехать в него на одной арендованной машине. Ежедневно в Нью-Йорк из мест проживания любого члена семьи отправляются десятки рейсов, все в разное время. Цена билета и время в пути для каждого рейса разные.

Загрузим эти данные в словарь, для которого ключом будет аэропорт отправления и аэропорт назначения, а значением – список, содержащий детальную информацию о рейсах.
'''

flights = {}
# 
for line in open('schedule.txt'):
    origin, dest, depart, arrive, price = line.strip().split(',')
    flights.setdefault((origin, dest), [])

    # Add details to the list of possible flights
    flights[(origin, dest)].append((depart, arrive, int(price)))

'''
Сейчас будет полезно написать служебную функцию getminutes , которая вычисляет смещение данного момента времени от начала суток в минутах. Так нам будет удобнее вычислять время в пути и время ожидания.
'''
def getminutes(t):
    x = time.strptime(t, '%H:%M')
    return x[3] * 60 + x[4]

'''
Для подобных задач необходимо определиться со способом представления потенциальных решений. Каждое число обозначает рейс, которым решил лететь участник группы, причем 0 – это первый рейс в течение суток, 1 – второй и т. д. Так как каждый человек должен лететь туда и обратно, то длина списка в два раза больше количества людей. 
Поскольку интерпретировать решение, имея перед собой лишь список чисел, трудно, нам понадобится функция, которая печатает выбранные рейсы в виде красиво отформатированной таблицы.
'''
def printschedule(r):
    rng = range(int(len(r) / 2))
    for d in rng:
        name = people[d][0]
        origin = people[d][1]
        out = flights[(origin, destination)][int(r[d])]
        ret = flights[(destination, origin)][int(r[d + 1])]
        print(
            '%10s%10s %5s-%5s $%3s %5s-%5s $%3s' % 
            (
                name, origin,
                out[0], out[1], out[2],
                ret[0], ret[1], ret[2]
            )
        )


# printschedule(s)


'''
Целевая функция
Ключом к решению любой задачи оптимизации является целевая функция, и именно ее обычно труднее всего отыскать. Цель оптимизационного алгоритма состоит в том, чтобы найти такой набор входных переменных – в данном случае рейсов, – который минимизирует целевую функцию. Поэтому целевая функция должна возвращать значение, показывающее, насколько данное решение неудовлетворительно. Не существует никакого определенного масштаба неудовлетворительности; требуется лишь, чтобы возвращаемое значение было тем больше, чем хуже решение.

Часто, когда переменных много, бывает трудно сформулировать критерий, хорошее получилось решение или плохое. Рассмотрим несколько параметров, которые можно измерить в примере с групповым путешествием:
    Цена - Полная стоимость всех билетов или, возможно, среднее значение, взвешенное с учетом финансовых возможностей.
    Время в пути - Суммарное время, проведенное всеми членами семьи в полете.
    Время ожидания - Время, проведенное в аэропорту в ожидании прибытия остальных членов группы.
    Время вылета - Если самолет вылетает рано утром, это может увеличивать общую стоимость из-за того, что путешественники не выспятся.
    Время аренды автомобилей - Если группа арендует машину, то вернуть ее следует до того часа, когда она была арендована, иначе придется платить за лишний день.

Определившись с тем, какие переменные влияют на стоимость, нужно решить, как из них составить одно число. В нашем случае можно, например, выразить в деньгах время в пути или время ожидания в аэропорту. Скажем, каждая минута в воздухе эквивалентна $1 (иначе говоря, можно потратить лишние $90 на прямой рейс, экономящий полтора часа), а каждая минута ожидания в аэропорту эквивалентна $0,50. Можно было бы также приплюсовать стоимость лишнего дня аренды машины, если для всех имеет смысл вернуться в аэропорт к более позднему часу. Кроме того, добавляется штраф $50, если машина возвращена в более поздний час, чем арендована.
'''

def schedulecost(sol):
    totalprice = 0
    latestarrival = 0
    earliestdep = 24 * 60

    for d in range(int(len(sol) / 2)):
        # Get the inbound and outbound flights
        origin = people[d][1]
        outbound = flights[(origin, destination)][int(sol[d])]
        returnf = flights[(destination, origin)][int(sol[d + 1])]

        # Total price is the price of all outbound and return flights
        totalprice += outbound[2]
        totalprice += returnf[2]

        # Track the latest arrival and earliest departure
        if latestarrival < getminutes(outbound[1]): 
            latestarrival = getminutes(outbound[1])
        if earliestdep > getminutes(returnf[0]): 
            earliestdep = getminutes(returnf[0])

    # Every person must wait at the airport until the latest person arrives.
    # They also must arrive at the same time and wait for their flights.
    totalwait = 0  
    for d in range(int(len(sol) / 2)):
        origin = people[d][1]
        outbound = flights[(origin, destination)][int(sol[d])]
        returnf = flights[(destination, origin)][int(sol[d + 1])]
        totalwait += latestarrival - getminutes(outbound[1])
        totalwait += getminutes(returnf[0]) - earliestdep  

    # Does this solution require an extra day of car rental? That'll be $50!
    if latestarrival > earliestdep: 
        totalprice += 50

    return totalprice + totalwait


# cost = schedulecost(s)
# print('cost', cost)

'''
    Теоретически можно испробовать все возможные комбинации, но в этом примере есть 16 рейсов и для каждого имеется девять вариантов, что в итоге дает 916 (около 300 миллиардов) комбинаций.
'''